#' Kalman smooth for already filtered linear Gaussian state space model
#'
#' Applies classic Kalman smoother algorithm to filtered model, assuming that the parameters of the
#' initial distribution are known.
#'
#' @return An object of class lgss.smoothed which holds all the results of the algorithm.
#'
#' @param filt A filtered linear Gaussian state space model of class lgss.filtered, usually generated by kfilter.
#'
#' @export
ksmooth <- function(filt) {
  if (!is.lgss.filtered(filt)) stop("This function requires an object of type 'lgss.filtered'")

  # A few useful sizes
  m <- nrow(filt$att)
  n <- ncol(filt$att)
  p <- nrow(filt$vt)

  # Smoothed distribution
  alphat <- matrix(nrow = m, ncol = n)
  Vt <- array(dim = c(m, m, n))

  # Recursion quantities
  rt <- matrix(nrow = m, ncol = n+1)
  Nt <- array(dim = c(m, p, n+1))

  # Initialization (from the end)
  alphat[, n] <- filt$att[, n]
  Vt[, , n] <- filt$Ptt[, , n]
  rt[, n+1] <- rep(0, nrow(rt))
  Nt[, , n+1] <- matrix(0, nrow = m, ncol = p)

  for (t in seq(n, 1)) {
    Lt <- filt$mod$A - filt$mod$A %*% filt$Pt[, , t] %*% t(filt$mod$Z) %*% solve(filt$Ft[, , t]) %*% filt$mod$Z

    rt[, t] <- t(filt$mod$Z) %*% solve(filt$Ft[, , t]) %*% filt$vt[, t] + t(Lt) %*% rt[, t+1]
    Nt[, , t] <- t(filt$mod$Z) %*% solve(filt$Ft[, , t]) %*% filt$mod$Z + t(Lt) %*% Nt[, , t+1] %*% Lt

    # Smoothing step
    alphat[, t] <- filt$at[, t] + filt$Pt[, , t] %*% rt[, t]
    Vt[, , t] <- filt$Pt[, , t] - filt$Pt[, , t] %*% Nt[, , t] %*% filt$Pt[, , t]
  }

  smoothed <- lgss.smoothed(filt, alphat, Vt)

  return(smoothed)
}
